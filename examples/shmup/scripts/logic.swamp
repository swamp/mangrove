use gameplay { 
    some_utility_function, 
    Something,
}

const SCREEN_HEIGHT = 180
const SCREEN_HEIGHT_F = 180.to_float()
const SCREEN_WIDTH = 320

struct Shot {
    x: Float,
    y: Float,
}

struct Position {
    x: Float,
    y: Float,
}

impl Position {
    fn new(x: Float, y: Float) -> Position {
        Position { x: x, y: y }
    }

    fn add(mut self, other: Position) {
        self.x = self.x + other.x
        self.y = self.y + other.y
    }

    fn floor(self) -> (Int, Int) {
        (self.x.floor(), self.y.floor())
    }
}

struct Size {
    width: Float,
    height: Float,
}

struct Rect {
    pos: Position,
    size: Size,
}

impl Rect {
    fn new(pos: Position, size: Size) -> Rect {
        Rect { pos: pos, size: size }
    }

    fn intersects(self, other: Rect) -> Bool {
        self.pos.x < other.pos.x + other.size.width &&
        self.pos.x + self.size.width > other.pos.x &&
        self.pos.y < other.pos.y + other.size.height &&
        self.pos.y + self.size.height > other.pos.y
    }
}


struct Player {
    fire: Bool,
    fire_cooldown: Int,
}

enum EnemyType {
    Alan,
    BonBon,
    Lips,
}

struct Waypoints {
    points: [Position],
}

enum FormationMovement {
    Waypoints(Waypoints),
    Sine,
}

struct Formation {
    movement: FormationMovement,
}

struct Enemy {
    rect: Rect,
    base_y: Float,
    direction: Float,
    enemy: EnemyType,
    formation: Int,
    time: Int,
}

enum ExplosionType {
    Fire, // TODO: add more types
}

struct Explosion {
    pos: Position,
    tick: Int,
    type: ExplosionType,
}

struct ScoreBonus {
    pos: Position,
        tick: Int,
    score: Int,
}

struct Logic {
    tick_count: Int, /// how many ticks have passed
    direction: Float, /// which direction the player ship
    pos: Position, /// the position of the player ship
    shots: std::Sparse<Shot>,
    enemies: std::Sparse<Enemy>,
    explosions: std::Sparse<Explosion>,
    score_bonus: std::Sparse<ScoreBonus>,
    players: [Int: Player],
    formations: [Int: Formation],
    cooldown_settings: [Int], // just to test arrays
    cooldown: Int?,
    score: Int,
    formation_id: Int,
    enemy_type: EnemyType,
}

impl Logic {

    fn random_range(value: Float, min: Int, max: Int) -> Int {
        min + (value.rnd() % (max - min))
    }

    fn random_range_int(value: Int, min: Int, max: Int) -> Int {
        min + (value.rnd() % (max - min))
    }

    fn check_shots_vs_enemies(mut self) {
        for shot_id, shot in self.shots {
            for enemy_id, enemy in self.enemies {
                shot_rect = Rect { pos: Position { x: shot.x, y: shot.y }, size: Size { width: 1.0, height: 2.0 } }
                if !enemy.rect.intersects(shot_rect) {
                    continue
                }
                self.shots.remove(shot_id)
                self.enemies.remove(enemy_id)
                score_for_enemy = 10
                self.explosions.add(Explosion { pos: enemy.rect.pos, tick: 0, type: ExplosionType::Fire })
                self.score_bonus.add(ScoreBonus { pos: enemy.rect.pos, tick: 0, score: score_for_enemy })
                self.score += score_for_enemy
            }
        }
    }

    fn tick_explosions(mut self) {
        for explosion_id, mut explosion in self.explosions {
            // This is just to show that the scope is not needed for if statements
            // But it is strongly recommended with '{' '}' for easier reading
            if explosion.tick >= 30 
                self.explosions.remove(explosion_id)
             else {
                explosion.tick += 1
                explosion.pos.x -= 1.5
            }
        }
    }

    fn tick_score_bonus(mut self) {
        for bonus_id, mut bonus in self.score_bonus {
            // This is just to show that the scope is not needed for if statements
            // But it is strongly recommended with '{' '}' for easier reading
            if bonus.tick >= 30 
                self.score_bonus.remove(bonus_id)
             else {
                bonus.tick += 1
            }
        }
    }

    fn check_player_input(mut self) {
        for mut player in self.players {
            if player.fire && player.fire_cooldown == 0 {
                self.shots.add(Shot {
                    x: self.pos.x + 12.0, 
                    y: self.pos.y + 4.0,
                })
                player.fire_cooldown = self.cooldown_settings[ 1 ]
                self.cooldown = player.fire_cooldown
            }
        }
    }

    fn next_enemy_type(e: EnemyType) -> EnemyType {
        match e {
            Alan => EnemyType::BonBon,
            BonBon => EnemyType::Lips,
            Lips => EnemyType::Alan,
        }
    }

    fn next_formation_enemy_type(mut self) -> EnemyType {
        self.enemy_type = Logic::next_enemy_type(self.enemy_type)
        match EnemyType::BonBon {
            Alan => print('alan'),
            BonBon => print('bonbon'),
            Lips => print('lips'),
        }
        print('next enemy {self.enemy_type}')
        self.enemy_type
    }

    fn create_formation(mut self) {
        self.formation_id += 1
        self.formation_id %= 32
        formation_id = self.formation_id

        enemy_type = self.next_formation_enemy_type()

        self.formations[formation_id] = Formation { movement: FormationMovement::Sine }

        count_in_formation = Logic::random_range_int(self.tick_count, 2, 4)

        const ENEMY_MARGIN = 20

        for offset_index in 0..count_in_formation {
            random_y = Logic::random_range_int(self.tick_count, ENEMY_MARGIN, SCREEN_HEIGHT - ENEMY_MARGIN)
            x_offset = offset_index * 32
            rect = Rect { 
                pos: Position { x: SCREEN_WIDTH.to_float() + 32.0 + x_offset.to_float(), y: random_y.to_float() }, 
                size: Size { width: 16.0, height: 16.0 } 
            }

            self.enemies.add(Enemy {
                rect: rect, 
                base_y: rect.pos.y,
                enemy: enemy_type, 
                direction: -1.2,
                formation: formation_id,
                time: x_offset,
            })
        }
    }

    fn players_fire_cooldown(mut self) {
        for mut player in self.players {
            if player.fire_cooldown > 0 {
                player.fire_cooldown -= 1
            } else {
                self.cooldown = none
            }
        }
    }

    // This is not normally how you structure the code
    // it is just to test mut arguments
    fn change_cooldown_setting(mut settings: Int, v: Int) {
        settings = v
    }

    // This is not normally how you structure the code
    // it is just to test mut arguments
    fn move_in_y_with_direction(mut position: Position, direction: Float) {
        const SHIP_Y_MARGIN = 20.0

        position.y += direction
        position.y = position.y.clamp(SHIP_Y_MARGIN, SCREEN_HEIGHT_F - SHIP_Y_MARGIN)
    }

    /// Called by the mangrove engine every logic tick
    fn tick(mut self) {
        self.tick_count += 1

        z = Something::new(5)
        a = some_utility_function(5)

        Logic::move_in_y_with_direction(mut self.pos, self.direction)

        if current_cooldown = self.cooldown? {
        }

        cooldown = self.cooldown
        if cooldown? {
        }

        if self.tick_count % 147 == 0 {
            self.create_formation()

            // This is just to test for in maps
            for player_id, player in self.players {
                print('player {player_id} fire: {player.fire} cooldown: {player.fire_cooldown} {self.cooldown}')
            }
        }

        const MAGNITUDE = 5.0

        for id, mut enemy in self.enemies {
            enemy.rect.pos.x += enemy.direction
            enemy.time += 1
            sway_time = enemy.time.to_float() * 0.01
            sway_angle = sway_time * 6.28
            y = sway_angle.cos() * MAGNITUDE

            enemy.rect.pos.y = enemy.base_y + y

            if enemy.rect.pos.x < -32.0 {
                self.enemies.remove(id)
            }
        }

        for shot_id, mut shot in self.shots {
            shot.x = shot.x + 8.0
            if shot.x > SCREEN_WIDTH.to_float() {
                self.shots.remove(shot_id)
            } 
        }

        self.tick_explosions()
        self.tick_score_bonus()
        self.check_shots_vs_enemies()
        self.check_player_input()
        self.players_fire_cooldown()
    }

    fn set_player_input_fire(mut self, player_id: Int, fire: Bool) {
        self.players[player_id].fire = fire
        Logic::change_cooldown_setting(mut self.cooldown_settings[ 1 ], 20)
    }

    /// Called by the mangrove engine when a gamepad axis changes
    fn gamepad_axis_changed(mut self, player_id: Int, axis: input::Axis, value: Float) {
        match axis {
            LeftStickY => self.direction = value * 1.1,
            _ => {},
        }
    }

    /// Called by the mangrove engine when a gamepad button changes
    fn gamepad_button_changed(mut self, player_id: Int, button: input::Button, value: Float) {
        match button {
            South => self.set_player_input_fire(player_id, value > 0.5),
            _ => print('not handled button: {button} value: {value}'),
        }
    }

}


/// Called by the mangrove engine at startup
fn main() -> Logic {
    const STARTING_POS = Position::new(20.0, 80.0)
    const FIRE_COOLDOWN = 15

    Logic {
        tick_count: 0,
        direction: 0.0,
        pos: STARTING_POS,
        shots: std::Sparse<Shot>::new(),
        enemies: std::Sparse<Enemy>::new(),
        explosions: std::Sparse<Explosion>::new(),
        score_bonus: std::Sparse<ScoreBonus>::new(),
        players: [ 0: Player { fire: false, fire_cooldown: 0 } ],
        cooldown_settings: [ 10, FIRE_COOLDOWN, 30 ],
        cooldown: none,
        formations: [],
        score: 0,
        formation_id: 0,
        enemy_type: EnemyType::Alan,
    }
}
