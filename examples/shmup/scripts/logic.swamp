struct Shot {
    x: Float,
    y: Float,
}

struct Position {
    x: Float,
    y: Float,
}

impl Position {
    fn new(x: Float, y: Float) -> Position {
        Position { x: x, y: y }
    }

    fn add(mut self, other: Position) {
        self.x = self.x + other.x
        self.y = self.y + other.y
    }
}

struct Size {
    width: Float,
    height: Float,
}

struct Rect {
    pos: Position,
    size: Size,
}

impl Rect {
    fn new(pos: Position, size: Size) -> Rect {
        Rect { pos: pos, size: size }
    }

    fn intersects(self, other: Rect) -> Bool {
        self.pos.x < other.pos.x + other.size.width &&
        self.pos.x + self.size.width > other.pos.x &&
        self.pos.y < other.pos.y + other.size.height &&
        self.pos.y + self.size.height > other.pos.y
    }
}


enum EnemyType {
    Alan,
    BonBon,
    Lips,
}

struct Enemy {
    rect: Rect,
    direction: Float,
    enemy: EnemyType,
}

enum ExplosionType {
    Fire, // TODO: add more types
}

struct Explosion {
    pos: Position,
    tick: Int,
    type: ExplosionType,
}

struct Logic {
    tick_count: Int, /// how many ticks have passed
    direction: Float, /// which direction the player ship
    x: Float, /// the x position of the player ship
    shots: std::Sparse<Shot>,
    enemies: std::Sparse<Enemy>,
    explosions: std::Sparse<Explosion>,
}

impl Logic {

    fn check_shots_vs_enemies(mut self) {
        for shot_id, shot in mut self.shots {
            for enemy_id, enemy in mut self.enemies {
                shot_rect = Rect { pos: Position { x: shot.x, y: shot.y }, size: Size { width: 1.0, height: 2.0 } }
                if !enemy.rect.intersects(shot_rect) {
                    continue
                }
                self.shots.remove(shot_id)
                self.enemies.remove(enemy_id)
                self.explosions.add(Explosion { pos: enemy.rect.pos, tick: 20, type: ExplosionType::Fire })
            }
        }
    }

    fn tick_explosions(mut self) {
        for explosion_id, explosion in mut self.explosions {
            if explosion.tick == 0 {
                self.explosions.remove(explosion_id)
            } else {
                explosion.tick = explosion.tick - 1
            }
        }
    }

    /// Called by the mangrove engine every logic tick
    fn tick(mut self) {
        self.x = self.x + self.direction

        self.tick_count = self.tick_count + 1
        if self.tick_count % 30 == 0 {
            rect = Rect { pos: Position { x: 10.0, y: 50.0 }, size: Size { width: 16.0, height: 16.0 } }
            self.enemies.add(Enemy { rect: rect, enemy: EnemyType::Alan, direction: 1.0 })
        }

        if self.tick_count % 10 == 0 {
            self.shots.add(Shot { x: self.x + 4.0, y: 18.0 })
        }

        for id, enemy in mut self.enemies {
            enemy.rect.pos.x = enemy.rect.pos.x + enemy.direction
            if enemy.rect.pos.x > 250.0 {
                self.enemies.remove(id)
            }
        }

        for shot_id, shot in mut self.shots {
            shot.y = shot.y + 3.0
            if shot.y > 250.0 {
                self.shots.remove(shot_id)
            } 

        }

        self.tick_explosions()

        self.check_shots_vs_enemies()
    }



    /// Called by the mangrove engine when a gamepad axis changes
    fn gamepad_axis_changed(mut self, gamepad: Int, axis: input::Axis, value: Float) {
        match axis {
            LeftStickX => self.direction = value * 4.0,
            _ => print('not handled axis: {axis} value: {value}'),
        }
    }

}

/// Called by the mangrove engine at startup
fn main() -> Logic {
    Logic {
        tick_count: 0,
        direction: 0.0,
        x: 0.0,
        shots: Sparse<Shot>::new(),
        enemies: Sparse<Enemy>::new(),
        explosions: Sparse<Explosion>::new(),
    }
}
