use gameplay { 
    some_utility_function, 
    Something,
}

use math {
    Rect,
    Position,
    Size,
}

const SCREEN_HEIGHT = 180
const SCREEN_HEIGHT_F = 180.to_float()
const SCREEN_WIDTH = 320
const SCREEN_WIDTH_F = 320.to_float()
const ENEMY_MARGIN = 20
const SHIP_Y_MARGIN = 20.0
const SHIP_X_MARGIN = 20.0
const MAGNITUDE = 8.0
const STARTING_POS = Position::new(20.0, 80.0)
const FIRE_COOLDOWN = 15

struct Shot {
    x: Float,
    y: Float,
}

struct Player {
    fire: Bool,
    fire_cooldown: Int,
    assigned_ship_index: std::SparseId?,
    direction: Position,
}

struct Ship {
    pos: Position,
    direction: Position,
    size: Size,
}

enum EnemyType {
    Alan,
    BonBon,
    Lips,
}

struct Waypoints {
    points: [Position],
}

enum FormationMovement {
    Waypoints(Waypoints),
    Sine,
}

struct Formation {
    movement: FormationMovement,
}

struct Enemy {
    rect: Rect,
    base_y: Float,
    direction: Float,
    enemy: EnemyType,
    formation: Int,
    time: Int,
}

enum ExplosionType {
    Fire, // TODO: add more types
}

struct Explosion {
    pos: Position,
    tick: Int,
    type: ExplosionType,
}

struct ScoreBonus {
    pos: Position,
        tick: Int,
    score: Int,
}

struct BonusItem {
    pos: Position,
}

struct Logic {
    tick_count: Int, /// how many ticks have passed
    ships: std::Sparse<Ship>,
    shots: std::Sparse<Shot>,
    enemies: std::Sparse<Enemy>,
    explosions: std::Sparse<Explosion>,
    score_bonus: std::Sparse<ScoreBonus>,
    bonus_items: std::Sparse<BonusItem>,
    players: [Int: Player],
    formations: [Int: Formation],
    cooldown_settings: [Int], // just to test arrays
    score: Int,
    formation_id: Int,
    enemy_type: EnemyType,
}

impl Logic {

    fn random_range(value: Float, min: Int, max: Int) -> Int {
        min + (value.rnd() % (max - min))
    }

    fn random_range_int(value: Int, min: Int, max: Int) -> Int {
        min + (value.rnd() % (max - min + 1))
    }


    fn has_enemies_in_formation(self, formation: Int) -> Bool {
        for enemy in self.enemies {
            if enemy.formation == formation {
                return true
            }
        }

        false
    }

    fn remove_enemy(mut self, id: std::SparseId) -> Bool {
        enemy = self.enemies[id]
        if enemy? {
            self.enemies.remove(id)

            if self.formations.has(enemy.formation) && !self.has_enemies_in_formation(enemy.formation) {
                self.formations.remove(enemy.formation)
                return true
            }
        }
        false
    }

    fn check_shots_vs_enemies(mut self) {
        for shot_id, shot in self.shots {
            for enemy_id, enemy in self.enemies {
                shot_rect = Rect { pos: Position { x: shot.x, y: shot.y }, size: Size { width: 1.0, height: 2.0 } }
                if !enemy.rect.intersects(shot_rect) {
                    continue
                }
                self.shots.remove(shot_id)
                was_last_in_formation = self.remove_enemy(enemy_id)
                score_for_enemy = 10
                self.explosions.add(Explosion { pos: enemy.rect.pos, tick: 0, type: ExplosionType::Fire })
                self.score_bonus.add(ScoreBonus { pos: enemy.rect.pos, tick: 0, score: score_for_enemy })
                self.score += score_for_enemy
                if was_last_in_formation {
                    _ = self.bonus_items.add(BonusItem { pos: enemy.rect.pos } )
                }
            }
        }
    }

    fn check_bonus_vs_ships(mut self) {
        for bonus_item_id, bonus_item in self.bonus_items {
            bonus_item_rect = Rect { 
                pos: Position { x: bonus_item.pos.x, y: bonus_item.pos.y }, 
                size: Size { width: 1.0, height: 2.0 },
            }

            for ships in self.ships {
                ship_rect = Rect { pos: ships.pos, size: ships.size }
                if !bonus_item_rect.intersects(ship_rect) {
                    continue
                }
                self.bonus_items.remove(bonus_item_id)
            }
        }
    }

    fn tick_explosions(mut self) {
        for explosion_id, mut explosion in self.explosions {
            // This is just to show off the guard expression syntax
            | explosion.tick >= 30 -> {
                _ = self.explosions.remove(explosion_id)
                }
            | _ -> {
                explosion.tick += 1
                explosion.pos.x += 0.9
            }
        }
    }

    fn tick_score_bonus(mut self) {
        for bonus_id, mut bonus in self.score_bonus {
            // This is just to show that the scope is not needed for if statements
            // But it is strongly recommended with '{' '}' for easier reading
            if bonus.tick >= 30 
                self.score_bonus.remove(bonus_id)
             else {
                bonus.tick += 1
            }
        }
    }

    fn tick_bonus_items(mut self) {
        for bonus_id, mut bonus_item in self.bonus_items {
            if bonus_item.pos.x < -30.0 {
                self.bonus_items.remove(bonus_id)
            } else {
                bonus_item.pos.x -= 0.6
            }
        }
    }

    fn check_player_input(mut self) {
        for mut player in self.players {
            if player.fire && player.assigned_ship_index == none {
                // continue
                // HACK
                ship2 = Ship {
                    pos: Position { x: 20.0, y: 80.0 },
                    direction: Position { x: 0.0, y: 0.0 },
                    size: Size { width: 16.0, height: 16.0 },
                }
                ship_id = self.ships.add(ship2)
                player.assigned_ship_index = ship_id
                print('player assigned to ship: {ship_id}')
            }
            if ship_index = player.assigned_ship_index? {
                ship = self.ships[ship_index]
                if ship? {
                    if player.fire && player.fire_cooldown == 0 {
                        self.shots.add(Shot {
                            x: ship.pos.x + 12.0, 
                            y: ship.pos.y + 4.0,
                        })
                        player.fire_cooldown = self.cooldown_settings[ 1 ]
                    }
                }
            }
        }
    }

    fn next_enemy_type(e: EnemyType) -> EnemyType {
        match e {
            Alan => EnemyType::BonBon,
            BonBon => EnemyType::Lips,
            Lips => EnemyType::Alan,
        }
    }

    fn next_formation_enemy_type(mut self) -> EnemyType {
        self.enemy_type = Logic::next_enemy_type(self.enemy_type)
        self.enemy_type
    }

    fn create_formation(mut self) {
        self.formation_id += 1
        self.formation_id %= 1024
        formation_id = self.formation_id

        enemy_type = self.next_formation_enemy_type()

        self.formations[formation_id] = Formation { movement: FormationMovement::Sine }

        count_in_formation = Logic::random_range_int(self.tick_count, 3, 5)

        for offset_index in 0..count_in_formation {
            random_y = Logic::random_range_int(self.tick_count, ENEMY_MARGIN, SCREEN_HEIGHT - ENEMY_MARGIN)
            x_offset = offset_index * 32
            rect = Rect { 
                pos: Position { x: SCREEN_WIDTH.to_float() + 32.0 + x_offset.to_float(), y: random_y.to_float() }, 
                size: Size { width: 16.0, height: 16.0 } 
            }

            _ = self.enemies.add(Enemy {
                rect: rect, 
                base_y: rect.pos.y,
                enemy: enemy_type, 
                direction: -1.2,
                formation: formation_id,
                time: x_offset,
            })
        }
    }

    fn players_fire_cooldown(mut self) {
        for mut player in self.players {
            if player.fire_cooldown > 0 {
                player.fire_cooldown -= 1
            }
        }
    }

    // This is not normally how you structure the code
    // it is just to test mut arguments
    fn change_cooldown_setting(mut settings: Int, v: Int) {
        settings = v
    }

    // This is not normally how you structure the code
    // it is just to test mut arguments
    fn move_in_y_with_direction(mut position: Position, direction: Float) { 
        position.y += direction // BUG: doesn't check mutability
        position.y = position.y.clamp(SHIP_Y_MARGIN, SCREEN_HEIGHT_F - SHIP_Y_MARGIN)
    }

    fn move_in_x_with_direction(mut position: Position, direction: Float) {
        position.x += direction * 1.3
        position.x = position.x.clamp(SHIP_X_MARGIN, SCREEN_WIDTH_F - SHIP_X_MARGIN)
    }

    fn move_ships(mut self) {
        for mut ship in self.ships {
            Logic::move_in_y_with_direction(mut ship.pos, ship.direction.y) // Bug didn't check mutability
            Logic::move_in_x_with_direction(mut ship.pos, ship.direction.x) // Bug didn't check mutability
        }
    }

    fn player_input_to_ship_direction(mut self, player: Player) {
        if ship_index = player.assigned_ship_index? {
            mut ship = mut self.ships[ship_index]
            if ship? {
                ship.direction = player.direction
            } else {
                print('ship not found!!')
            }
        } else {
            print('ship not assigned yet, press fire to assign')
        }
    }

    /// Called by the mangrove engine every logic tick
    fn tick(mut self) {
        self.tick_count += 1

        // Input from players to ships
        for player in self.players {
            self.player_input_to_ship_direction(player)
        }

        self.move_ships()

        // print('cooldown: {cooldown ?? -1} is the value \n\xF0\x9F\x90\x8A\u(1F40A)NEXT LINE (üêä)')
    
        if self.tick_count % 257 == 0 {
            self.create_formation()
        }

        // Update enemies
        with mut self, mut enemies = self.enemies {
            for id, mut enemy in enemies {
                enemy.rect.pos.x += enemy.direction * 1.0
                enemy.time += 1
                sway_time = enemy.time.to_float() * 0.02
                sway_angle = sway_time * 6.28
                y = sway_angle.cos() * MAGNITUDE
                enemy.rect.pos.y = enemy.base_y + y

                if enemy.rect.pos.x < -32.0 {
                    self.formations.remove(enemy.formation) // if player missed this, then remove formation
                    self.remove_enemy(id)
                }
            }
        }

        // Update shots
        with mut shots = mut self.shots {
            for shot_id, mut shot in shots {
                shot.x = shot.x + 8.0
                if shot.x > SCREEN_WIDTH.to_float() {
                    shots.remove(shot_id)
                } 
            }
        }

        self.tick_explosions()
        self.tick_score_bonus()
        self.check_bonus_vs_ships()
        self.tick_bonus_items()
        self.check_shots_vs_enemies()
        self.check_player_input()
        self.players_fire_cooldown()
    }

    fn set_player_input_fire(mut self, player_id: Int, fire: Bool) {
        self.players[player_id].fire = fire
        Logic::change_cooldown_setting(mut self.cooldown_settings[ 1 ], 20)
    }

    /// Called by the mangrove engine when a gamepad axis changes
    fn gamepad_axis_changed(mut self, player_id: Int, axis: input::Axis, value: Float) {
        mut player = mut self.players[player_id]
    
        if mut new_player = player? {
            match axis {
                LeftStickY => {
                    new_player.direction.y = value
                    },
                LeftStickX => {
                    new_player.direction.x = value
                    },
                _ => {},
            }
        }
    }

    fn some_guard() -> Bool {
        true
    }

    /// Called by the mangrove engine when a gamepad button changes
    fn gamepad_button_changed(mut self, player_id: Int, button: input::Button, value: Float) {
        match button {
            South | Logic::some_guard() && true => self.set_player_input_fire(player_id, value > 0.1),
            _ => print('not handled button: {button} value: {value}'),
        }
    }
}

/// Called by the mangrove engine at startup
fn main() -> Logic {
    player = Player { 
        fire: false, 
        fire_cooldown: 0, 
        assigned_ship_index: none, 
        direction: Position { x: 0.0, y: 0.0 }
    }

    Logic {
        tick_count: 0,
        shots: std::Sparse<Shot>::new(),
        enemies: std::Sparse<Enemy>::new(),
        explosions: std::Sparse<Explosion>::new(),
        score_bonus: std::Sparse<ScoreBonus>::new(),
        bonus_items: std::Sparse<BonusItem>::new(),
        players: [ 0: player ],
        ships: std::Sparse<Ship>::new(),
        cooldown_settings: [ 10, FIRE_COOLDOWN, 30 ],
        formations: [],
        score: 0,
        formation_id: 0,
        enemy_type: EnemyType::Alan,
    }
}
