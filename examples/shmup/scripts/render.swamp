use mangrove.render {
    SpriteParams,
    Color,
}

const SCREEN_HEIGHT = 180
const SCREEN_HEIGHT_F = 180.to_float()
const SCREEN_WIDTH = 320

/// Handles the rendering of the game
struct Render {
    player_ship_material: mangrove::render::FixedAtlasHandle,
    player_shot_material: mangrove::render::FixedAtlasHandle,
    alan_material: mangrove::render::FixedAtlasHandle,
    explosion_material: mangrove::render::FixedAtlasHandle,
    background_material: mangrove::render::MaterialHandle,
    font_and_material: mangrove::render::FontAndMaterialHandle,
    tick: Int,
    background_x: Float,
}


impl Render {

    fn new(mut assets: mangrove::render::Assets) -> Render {
        const SIZE = 16
        const SHIP_TEXTURE_SIZE = (SIZE*3, SIZE)
        const CELL_SIZE = (SIZE, SIZE)

        player_ship_material = assets.frame_fixed_grid_material_png('player/ship_16x16', CELL_SIZE, SHIP_TEXTURE_SIZE)

        Render {
            player_ship_material: player_ship_material,
            player_shot_material: assets.frame_fixed_grid_material_png('projectiles/player_beam', (8,SIZE), (SIZE*2, SIZE)),
            alan_material: assets.frame_fixed_grid_material_png('enemies/alan_16x16', CELL_SIZE, (SIZE*6, SIZE)),
            explosion_material: assets.frame_fixed_grid_material_png('effects/explosion_16x16', CELL_SIZE, (SIZE*6, SIZE)),
            background_material: assets.material_png('blue_nebula_04-512x512'),
            font_and_material: assets.bm_font('font/hackman'),
            tick: 0,
            background_x: 0.0,
        }
    }

    fn fill_zeroes(s: String, len: Int) -> String {
        mut x = s
        while x.len() < len {
            x = "0" + x 
        }
        x
    }

    fn render_score_bonus(self, mut gfx: mangrove::render::Gfx, bonuses: std::Sparse<logic::ScoreBonus>) {
        for id, bonus in bonuses {
            score_string = Render::fill_zeroes('{bonus.score}', 2)

            pos_3d = (bonus.pos.x.round(), bonus.pos.y.round(), 0)
            gfx.text(pos_3d, score_string, self.font_and_material, Color::new(1.0, 1.0, 1.0, 0.5))
        }
    }

    /// Called by the mangrove engine every render tick
    fn render(mut self, logic: logic::Logic, mut gfx: mangrove::render::Gfx) {
        self.tick += 1
        x, y = logic.pos.floor()

        player_ship_pos = (x, y, 10)
        sprite_size = (16, 16)

        ship_frame = match logic.direction.sign() {
            1.0 => 0,
            -1.0 => 2,
            _ => 1,
        }

        self.background_x += 0.5
        self.background_x = self.background_x % 512.0

        score_string = Render::fill_zeroes('{logic.score}', 6)

        gfx.text((SCREEN_WIDTH-60, SCREEN_HEIGHT-30, 0), 'SCORE {score_string}', self.font_and_material, Color::new(1.0, 1.0, 1.0, 0.5))

        gfx.sprite_ex((0, 0, -100), self.background_material, SpriteParams {
            color: Color::new(1.0, 1.0, 1.0, 0.5),
            uv: (self.background_x.floor(), 0),
            ..
        })

        const STANDARD_ROTATE = 3

        ship_sprite_params = SpriteParams {
            rotate: STANDARD_ROTATE,
            ..
        }

        gfx.sprite_atlas_frame_ex(player_ship_pos, self.player_ship_material, ship_frame, ship_sprite_params)

        power = (self.tick % 10).to_float() / 10.0
        shot_sprite_params = SpriteParams {
            rotate: 3, // Rotation is counterclockwise
            color: Color::new(1.0, 1.0, 1.0, power),
            ..
        }

        self.render_score_bonus(gfx, logic.score_bonus)

        for shot in logic.shots {
            shot_pos = (shot.x.floor(), shot.y.floor(), 0)

            gfx.sprite_atlas_frame_ex(shot_pos, self.player_shot_material, 1, shot_sprite_params)
        }

        for id, enemy in logic.enemies {
            enemy_pos = (enemy.rect.pos.x.floor(), enemy.rect.pos.y.floor(), 0)
            pulsating_time = enemy.time % 53
            frame = if pulsating_time < 40  pulsating_time/10  else  0 
            match enemy.enemy {
                Alan => gfx.sprite_atlas_frame(enemy_pos, self.alan_material, frame),
                _ => print('not handled enemy type: {enemy.enemy}'),
            }
        }

        for explosion in logic.explosions {
            explosion_pos = (explosion.pos.x.floor() + 4, explosion.pos.y.floor(), 0)
            mut frame = explosion.tick / 3
            if frame > 5 {
                frame = 5
            }
            gfx.sprite_atlas_frame(explosion_pos, self.explosion_material, frame)
        }
    }

}

/// Called by the mangrove engine at startup
fn main(mut assets: mangrove::render::Assets) -> Render {
    Render::new(assets)
}
